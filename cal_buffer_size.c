#include<stdio.h>
#include<stdlib.h> //handle system("pause")，结束后不立即退出
#include<math.h>
#include<time.h>

#define max2 230000000 //buffer_shrink
#define list 15000 //幂的列表
//-------------------------------------------------------------------------------------------------//
//目标与控制
#define Target_number (double)8.080174247945128e+53//8.08017424794512875815e+53 //double t;t=powl(2,46)*powl(3,20)*powl(5,9)*powl(7,6)*powl(11,2)*powl(13,3)*17*19*23*29*31*41*47*59*71;printf("%.15Le\n",t);
#define Target_diva 3e-13
#define All_pass_start 0//8250000//分段时开始计算偏移的数组头，legacy parameter
#define All_pass_end i1_t[power_length-1]/3
//组成的常数
//#define self 1//could be generated by ^0
//Physics
#define Speed_of_light 2.99792458e8
#define Proton_length 1.754e-15//0.84e-15--0.87e-15/0.833e-15
#define Planck_constant 6.62607015e-34
#define Planck_constant_reduced 1.054571817646156391262428e-34
#define Planck_time 5.39116e-44
#define Planck_mass 2.176434e-8
#define Planck_length 1.616229e-35
#define Proton_mass 1.6726231e-27
#define Gravitational_constant 6.67430e-11
#define Charge 1.602176e-19
#define Vacuum_Permittivity_E0 8.854187817e-12
#define Vacuum_Permittivity_u0 1.25663706212e-6
#define Coulomb_constant_F 8.9875517923e9
#define Conductance_quantum 7.748091729e-5
#define Wien_constant 2.897771955e-3
//Chemistry
#define Boltzmann_constant 1.380649e-23
#define Stefan_Boltzmann_constant 5.670374419e-8
#define gas_constant_R 8.3144598
#define Faraday_constant_F 9.648533212e4
#define Avogadro_constant 6.02214076e23
//math
#define Chaos_costant 4.6692016
#ifndef Pi
#define Pi 3.1415926535897932384626433832795
#endif
#define mathematical_constant_e 2.71828182845904523536028747135266249775724709369995
#define golden_ratio 1.6180339887498948482045868343656

//-------------------------------------------------------------------------------------------------//
//divation define 最终运行完后寻找的分子分母
//#define uper  1.024394e-56
//#define lower 8.277284e-03
#define uper  6.559092e-56
#define lower 5.299861e-02
//-------------------------------------------------------------------------------------------------//
//Control
//#define debug //multi_error
#define print
//#define print_buffer_before_sort
//#define print_buffer_before_shrink
//#define print_buffer_after_shrink

//#define original_single_thread
//#define multi_thread

//三选一
//#define multi_sort
//#define my_sort
#define my_qsort

#define all_pass
//-------------------------------------------------------------------------------------------------//
//全局变量
long int count = 0;         //删掉后剩下的数据
long int count_del = 0;     //删掉的重复数据
long int local_count = 0;   //在指定diva中的个数
clock_t start_time;

#ifdef multi_thread
#include<pthread.h>
#define core_count 8    
pthread_t th[core_count];                               //设定的线程数
#define all_work_group 373621248                        //373621248
double* buffer_original, * buffer_original_save;          //原始数组
double* buffer_o_thread[core_count];                    //每个线程的数组指针
long int total_pushed_thread[core_count];               //数组排序删前每个线程的数组个数
int total_pushed = 0;                                     //所有线程的生成个数之和
double* buffer_shrink, * buffer_shrink_save;              //删除后留下的数组
#endif
#ifndef multi_thread
#define max1 1373621248 //buffer_original
double* buffer_original, * buffer_original_save;//原始数组
double* buffer_shrink, * buffer_shrink_save;//删除后留下的数组
unsigned long long total_pushed = 0;  //数组排序删前的个数
unsigned long long zero = 0;
#endif
/*double stack[] =  {Planck_length,Planck_mass,Planck_time,Planck_constant,
                            Speed_of_light,Charge,Avogadro_constant,Gravitational_constant,Boltzmann_constant,
                            Pi,Chaos_costant,mathematical_constant_e,golden_ratio,Vacuum_Permittivity_E0,
                            Proton_length,Proton_mass};*///self_old
double stack[] = { Planck_length,Planck_mass,Planck_time,Planck_constant,
                            Speed_of_light,Charge,Avogadro_constant,Gravitational_constant,Boltzmann_constant,
                            Pi,Chaos_costant,mathematical_constant_e,golden_ratio,Vacuum_Permittivity_E0,
                            Proton_length,Proton_mass
                            ,Stefan_Boltzmann_constant,gas_constant_R,Faraday_constant_F,
                            Planck_constant_reduced,Vacuum_Permittivity_u0,Coulomb_constant_F,
                            Conductance_quantum,Wien_constant
};
int length_ele = 24;//how to calculate : printf("%d\n",sizeof(stack) / sizeof(stack[0]));
int length_ele_extended = 24 * 5;
//-------------------------------------------------------------------------------------------------//
//用户函数
void quicksort(int left, int right, double* buffer);
#ifdef multi_thread
void* quicksort_thread(void* args)
{
    int tid = *((int*)args);
    printf("tid = %d quick_sort_perioud %d %d\n", tid, tid * all_work_group / core_count, (tid + 1) * all_work_group / core_count - 1);
    quicksort(tid * all_work_group / core_count, (tid + 1) * all_work_group / core_count - 1, buffer_original);
    pthread_exit(0);
}
void* sub_pass(void* args)
{
    double A_buffer, B_buffer, C_buffer, D_buffer, E_buffer, F_buffer;
    double s1, s2, s3, s4, s5, s6, s7;
    pthread_t	tid;
    tid = pthread_self() - 1;
    printf("tid in thread = %d\n", tid);//线程id
    //printf("%d\n",(tid)*all_work_group/core_count);//确认分组是否正确
    int i, j, k, l, m, o;
    int round = 0;//判断该循环是否是该线程需要算的
    for (i = 0; i < length_ele; i++)   //产生6个一组的数据
        for (j = i + 1; j < length_ele; j++)
            for (k = j + 1; k < length_ele; k++)
                for (l = k + 1; l < length_ele; l++)
                    for (m = l + 1; m < length_ele; m++)
                        for (o = m + 1; o < length_ele; o++)
                        {
                            if (round % core_count == tid)//只计算相应线程的数据
                                for (s1 = -0.5; s1 <= 2; s1 += 0.5)
                                    for (s2 = -0.5; s2 <= 2; s2 += 0.5)
                                        for (s3 = -0.5; s3 <= 2; s3 += 0.5)
                                            for (s4 = -0.5; s4 <= 2; s4 += 0.5)
                                                for (s5 = -0.5; s5 <= 2; s5 += 0.5)
                                                    for (s6 = -0.5; s6 <= 2; s6 += 0.5)
                                                    {
                                                        A_buffer = powl(stack[i], s1);
                                                        B_buffer = powl(stack[j], s2);
                                                        C_buffer = powl(stack[k], s3);
                                                        D_buffer = powl(stack[l], s4);
                                                        E_buffer = powl(stack[m], s5);
                                                        F_buffer = powl(stack[o], s6);
                                                        *buffer_o_thread[tid] = A_buffer * B_buffer * C_buffer * D_buffer * E_buffer * F_buffer;
                                                        //printf("tid a= %d %e\n",tid,*buffer_o_thread[tid]);
#ifdef debug      
                                                        if ((*buffer_o_thread[tid] >= uper * 0.999999 & *buffer_o_thread[tid] <= uper * 1.0000001) || (*buffer_o_thread[tid] >= lower * 0.9999999 & *buffer_o_thread[tid] <= lower * 1.000001))
                                                        {
                                                            printf("count = %d\n", total_pushed_thread[tid]);
                                                            printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                                                            printf("stack[i] = %e stack[j] = %e stack[k] = %e stack[l] = %e stack[m] = %e stack[o] = %e\n", stack[i], stack[j], stack[k], stack[l], stack[m], stack[o]);
                                                            printf("s1 == %.1f s2 == %.1f s3 == %.1f s4 == %.1f s5 == %.1f s6 == %.1f\n", s1, s2, s3, s4, s5, s6);
                                                            printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n", A_buffer, B_buffer, C_buffer, D_buffer, E_buffer, F_buffer);
                                                            printf("*buffer_o_thread[tid] == %e", *buffer_o_thread[tid]);
                                                            printf("\n\n");
                                                        }
#endif
                                                        buffer_o_thread[tid]++;
                                                        total_pushed_thread[tid]++;
                                                        if (total_pushed_thread[tid] % 20000000 == 0)printf("tid = %d push = %d\n", tid, total_pushed_thread[tid]);
                                                    }
                            round++;
                        }
    pthread_exit(0);//退出线程
}
#endif
double choose_operator(double t1, double t2, char key)
{
    switch (key)
    {
    case '+':
        return t1 + t2;
        break;
    case '-':
        return t1 - t2;
        break;
    case '*':
        return t1 * t2;
        break;
    case '/':
        return t1 / t2;
        break;
    default:
        return t1;
        break;
    }
}
double calculate_divation(double result)
{
    return result / Target_number - 1;
}
void quicksort(int left, int right, double* buffer) {
    int i = left, j = right;
    double mid = buffer[(left + right) / 2];//请注意，在处理的过程中a[(left+right)/2]的值是会变化的
    double t;
    while (i <= j) {//i,j的值是会跳跃的,循环结束时i>j 
        while (buffer[i] < mid)
            i++;
        while (buffer[j] > mid)
            j--;
        if (i <= j) {
            t = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = t;
            i++;
            j--;
        }
    }
    if (i < right)
        quicksort(i, right, buffer);
    if (left < j)
        quicksort(left, j, buffer);
}
int qsort_cmp(const void* a, const void* b) {
    return ((*(double*)a - *(double*)b) > 0 ? 1 : -1);//升序
    //	return ((*(double *)a - *(double *)b)<0?1:-1);//降序
}
void print_time(clock_t func_time)
{
    clock_t end_time;
    end_time = clock();
    printf("%lf\n", (double)(end_time - func_time) / CLOCKS_PER_SEC);
}
int main(void)
{
    printf("Started\n");
    start_time = clock();
    length_ele = sizeof(stack) / sizeof(stack[0]);
    length_ele_extended = sizeof(stack) / sizeof(stack[0]) * 5;
    char symbol[4] = { '+', '-', '*', '/' };

#ifdef multi_thread
    //产生6个一组的数据 外层大循环8008 all = 8008 * 6 ^ 6 = 373621248
    int i, j;
    buffer_original = (double*)malloc(all_work_group * sizeof(double));
    buffer_original_save = buffer_original;
    buffer_shrink = (double*)malloc(max2 * sizeof(double));
    buffer_shrink_save = buffer_shrink;
    for (i = 0; i < core_count; i++)
    {
        buffer_o_thread[i] = buffer_original + i * all_work_group / core_count;//指针分配
    }
    for (i = 0; i < core_count; i++)
    {
        pthread_create(&th[i], NULL, sub_pass, NULL);
    }
    for (i = 0; i < core_count; i++)
    {
        pthread_join(th[i], NULL);
    }
    buffer_original = buffer_original_save;//指针复原
    for (i = 0; i < core_count; i++)//total_pushed从thread中汇总相加
    {
        total_pushed += total_pushed_thread[i];
        //buffer_o_thread[i] = buffer_original+i*all_work_group/core_count;//应该是不要的
    }
    printf("total pushed before quick sort =%d\n", total_pushed);
#endif
#ifndef multi_thread
    buffer_original = (double*)malloc(max1 * sizeof(double));
    buffer_original_save = buffer_original;
    buffer_shrink = (double*)malloc(max2 * sizeof(double));
    buffer_shrink_save = buffer_shrink;
    int i, j, k, l, m, o;
    double A_buffer, B_buffer, C_buffer, D_buffer, E_buffer, F_buffer;
    double s1, s2, s3, s4, s5, s6;
    double stack_extended[sizeof(stack) / sizeof(stack[0]) * 5];
#ifndef original_single_thread
    for (i = 0; i < length_ele; i++)
    {
        stack_extended[i + 0 * length_ele] = stack[i];
        stack_extended[i + 1 * length_ele] = powl(stack[i], 2);
        stack_extended[i + 2 * length_ele] = powl(stack[i], 0.5);
        stack_extended[i + 3 * length_ele] = powl(stack[i], 1.5);
        stack_extended[i + 4 * length_ele] = powl(stack[i], -0.5);
    }
#ifdef print_extended_constant_before_sort
    printf("extended constant before sort\n");
    for (i = 0; i < length_ele_extended; i++)
    {
        printf("before i = %d %le\n", i, stack_extended[i]);
    }
#endif
    quicksort(0, length_ele_extended - 1, stack_extended);
#ifdef print_extended_constant_after_sort
    printf("extended constant after sort\n");
    for (i = 0; i < length_ele_extended; i++)
    {
        printf("after i = %d %le\n", i, stack_extended[i]);
    }
#endif
    int total_pushed_t = 0;
    int total_pushed_h = 0;
    for (i = 0; i < length_ele_extended; i++)   //产生6个一组的数据
        for (j = i + 1; j < length_ele_extended; j++)
            for (k = j + 1; k < length_ele_extended; k++)
                for (l = k + 1; l < length_ele_extended; l++)
                    for (m = l + 1; m < length_ele_extended; m++)
                        for (o = m + 1; o < length_ele_extended; o++)
                        {
                            // *buffer_original = stack_extended[i]*stack_extended[j]*stack_extended[k]
                            //                     *stack_extended[l]*stack_extended[m]*stack_extended[o];
                            // #ifdef debug      
                            //     if((*buffer_original >= uper * 0.999999 & *buffer_original <= uper * 1.0000001 )|| (*buffer_original >= lower * 0.9999999 & *buffer_original <= lower * 1.000001))
                            //     {
                            //         printf("count = %d\n",total_pushed);
                            //         printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                            //         //printf("stack[i] = %e stack[j] = %e stack[k] = %e stack[l] = %e stack[m] = %e stack[o] = %e\n",stack[i],stack[j],stack[k],stack[l],stack[m],stack[o]);
                            //         //printf("s1 == %.1f s2 == %.1f s3 == %.1f s4 == %.1f s5 == %.1f s6 == %.1f\n",  s1, s2, s3, s4, s5, s6);
                            //         printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n",
                            //         stack_extended[i],stack_extended[j],stack_extended[k],stack_extended[l],stack_extended[m],stack_extended[o]);
                            //         printf("*buffer_original == %e",*buffer_original);
                            //         printf("\n\n");
                            //     }
                            // #endif
                            // if(*buffer_original == 0)//超出最小精度
                            // {
                            //     if(zero < 100)
                            //     {
                            //         //printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                            //         //printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n",
                            //         //stack_extended[i],stack_extended[j],stack_extended[k],stack_extended[l],stack_extended[m],stack_extended[o]);
                            //     }
                            //     zero++;
                            // }
                            // else
                            // {
                            //     buffer_original++;
                            //     total_pushed++;
                            //     if(total_pushed % 50000000 == 0)printf("push = %d buffer_current = %e\n",total_pushed,*(buffer_original-1));
                            // }
                            total_pushed++;
                            if (total_pushed % 200000000 == 0)printf("push = %lld\n", total_pushed);
                        }
#ifdef print
    //最大没有外溢
    printf("total pushed before quick sort =%lld zero = %lld\n", total_pushed, zero);
    printf("sample_head\n");
    buffer_original = buffer_original_save;
    //for(i=0;i<200;i++) {printf("%d %e\n",i,*buffer_original); buffer_original++;}
    //printf("sample_tail\n");
    //for(i=total_pushed-100;i<total_pushed;i++) {printf("%e\n",*buffer_original+i); }
    buffer_original = buffer_original_save;
#endif
#endif
    //-------------------------------------------------------------------------------------------------//
            //原来的单线程组合程序
#ifdef original_single_thread
    for (i = 0; i < length_ele; i++)   //产生6个一组的数据
        for (j = i + 1; j < length_ele; j++)
            for (k = j + 1; k < length_ele; k++)
                for (l = k + 1; l < length_ele; l++)
                    for (m = l + 1; m < length_ele; m++)
                        for (o = m + 1; o < length_ele; o++)
                        {
                            for (s1 = -0.5; s1 <= 2; s1 += 0.5)
                                for (s2 = -0.5; s2 <= 2; s2 += 0.5)
                                    for (s3 = -0.5; s3 <= 2; s3 += 0.5)
                                        for (s4 = -0.5; s4 <= 2; s4 += 0.5)
                                            for (s5 = -0.5; s5 <= 2; s5 += 0.5)
                                                for (s6 = -0.5; s6 <= 2; s6 += 0.5)
                                                {
                                                    A_buffer = powl(stack[i], s1);
                                                    B_buffer = powl(stack[j], s2);
                                                    C_buffer = powl(stack[k], s3);
                                                    D_buffer = powl(stack[l], s4);
                                                    E_buffer = powl(stack[m], s5);
                                                    F_buffer = powl(stack[o], s6);
                                                    *buffer_original = A_buffer * B_buffer * C_buffer * D_buffer * E_buffer * F_buffer;
#ifdef debug      
                                                    if ((*buffer_original >= uper * 0.999999 & *buffer_original <= uper * 1.0000001) || (*buffer_original >= lower * 0.9999999 & *buffer_original <= lower * 1.000001))
                                                    {
                                                        printf("count = %d\n", total_pushed);
                                                        printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                                                        printf("stack[i] = %e stack[j] = %e stack[k] = %e stack[l] = %e stack[m] = %e stack[o] = %e\n", stack[i], stack[j], stack[k], stack[l], stack[m], stack[o]);
                                                        printf("s1 == %.1f s2 == %.1f s3 == %.1f s4 == %.1f s5 == %.1f s6 == %.1f\n", s1, s2, s3, s4, s5, s6);
                                                        printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n", A_buffer, B_buffer, C_buffer, D_buffer, E_buffer, F_buffer);
                                                        printf("*buffer_original == %e", *buffer_original);
                                                        printf("\n\n");
                                                    }
#endif
                                                    buffer_original++;
                                                    total_pushed++;
                                                    if (total_pushed % 20000000 == 0)printf("push = %d\n", total_pushed);
                                                }
                        }
    buffer_original = buffer_original_save;
#endif
#endif
    //-------------------------------------------------------------------------------------------------//
    //quick sort
#ifdef print_buffer_before_sort
    printf("before sort\n");
    printf("total_pushed = %ld\n", total_pushed);
    printf("original buffer before quicksort tail=%e tail+1 = %e head=%e\n", buffer_original[total_pushed - 1], buffer_original[total_pushed], buffer_original[0]);
    printf("head10\n");
    for (i = 0; i < 10; i++) printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
    printf("tail10\n");
    for (i = total_pushed - 10; i < total_pushed; i++) printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
#endif
#ifdef multi_sort
    //先分组单独快排，再总体排序，速度没有变快
    printf("Time before individual quicksort\n");
    print_time(start_time);
    for (i = 0; i < core_count; i++)
    {
        printf("%d\n", i);//不能去，不知道为什么
        int* p = &i;
        pthread_create(&th[i], NULL, quicksort_thread, (void*)&i);
    }
    for (i = 0; i < core_count; i++)
    {
        pthread_join(th[i], NULL);
    }
    printf("Time after individual quicksort\n");
    print_time(start_time);
    buffer_original = buffer_original_save;
    quicksort(0, total_pushed - 1, buffer_original);
    printf("Time after whole quicksort\n");
    print_time(start_time);
#endif
#ifndef multi_sort
#ifdef my_sort
    printf("Time before my_quicksort\n");
    print_time(start_time);
    buffer_original = buffer_original_save;
    quicksort(0, total_pushed - 1, buffer_original);    //快排
    printf("Time after my_quicksort\n");
    print_time(start_time);
#endif
#ifdef my_qsort
    printf("Time before qsort\n");
    print_time(start_time);
    buffer_original = buffer_original_save;
    qsort(buffer_original, total_pushed, sizeof(double), qsort_cmp);
    printf("Time after qsort\n");
    print_time(start_time);
#endif
#endif
#ifdef print_buffer_before_shrink
    printf("after quicksort before shirink\n");
    for (i = 0; i < 350; i++) printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
    printf("original buffer after quicksort tail=%e tail+1 = %e head=%e\n", buffer_original[total_pushed - 1], buffer_original[total_pushed], buffer_original[0]);
    printf("total_pushed = %ld\n", total_pushed);
#endif
    buffer_original = buffer_original_save;
    for (i = 0; i < total_pushed; i++)                         //清除重复项
    {
        //if(i % 20000000 == 0) printf("count = %ld count_del = %ld i = %d\n",count,count_del,i);
        if (buffer_original[i] != buffer_original[i + 1]) { //two method buffer[i] != buffer[i+1];buffer[i] <= buffer[i+1] * (double)0.9999999999;
            buffer_shrink[count] = buffer_original[i];
            count++;
        }
        else {
            //printf("%e %e\n",buffer_original[i],buffer_original[i+1]); //判断清除条件
            count_del++;
        }
    }
    printf("count = %ld count_del = %ld\n", count, count_del);
    printf("Time after deleting duplicate\n");
    print_time(start_time);

#ifdef print_buffer_after_shrink
    for (i = 0; i < 100; i++) printf("count = %ld buffer_shrink[i] = %e\n", i, buffer_shrink[i]);
    printf("count = %ld buffer_shrink's tail = %e\n", count, buffer_shrink[count - 1]);
    printf("count = %ld buffer_shrink's tail = %e\n", count + 1, buffer_shrink[count]);//确认count-1是最后的对尾，count中无数据
    printf("total_pushed = %ld buffer_original's tail = %e\n", total_pushed, buffer_original[total_pushed - 1]);//原有buffer和缩短buffer对比确认
#endif
    free(buffer_original);//清内存
    //-------------------------------------------------------------------------------------------------//
    //幂函数分组归类
    //发现顺序排好之后不用表更快
    //-------------------------------------------------------------------------------------------------//
    //all pass
#ifdef all_pass
    int i_t[list], j_t[list];
    double s1_t[list], s2_t[list];
    double diva_t[list], diva;
    double ideal_number;//理想中对应的目标数值
    double diva_plus, diva_minus;//插入后左右diva正负不同
    j = 0;
    for (i = All_pass_start; i < All_pass_start + count - 1; i++)//i1_t[power_length-1] All_pass_end
    {
        ideal_number = Target_number * buffer_shrink[i];
        if (ideal_number > buffer_shrink[count - 1]) break;//目标值大于数组中存在的最大值直接退出循环
        while (buffer_shrink[j] < ideal_number)
        {
            if (j < count)j++;//如果j移动到count外会越界,j是连续记录，重复不多
        }
        //printf("ideal_number = %e number_in_que-1 = %e number_in_que+1 = %e\n",ideal_number,buffer_shrink[j-1],buffer_shrink[j]);
        //printf("%d\n",j);
        diva_minus = -calculate_divation(buffer_shrink[j - 1] / buffer_shrink[i]);//左
        diva_plus = calculate_divation(buffer_shrink[j] / buffer_shrink[i]);//右
        if (diva_minus < diva_plus && diva_minus < Target_diva)
        {
            i_t[local_count] = i;
            j_t[local_count] = j - 1;
            diva_t[local_count] = diva_minus;
            local_count++;
        }
        else if (diva_plus < diva_minus && diva_plus < Target_diva)
        {
            i_t[local_count] = i;
            j_t[local_count] = j;
            diva_t[local_count] = diva_plus;
            local_count++;
        }
        j--;
    }
    //-------------------------------------------------------------------------------------------------//
    //print result跑完后打印结果
    for (i = 0; i < local_count; i++) //搜索完成后打印符合的选项
    {
        printf("count = %d i = %d j = %d ", i, i_t[i], j_t[i]);
        printf("buffer_original[i] = %e buffer_original[j] = %e ", buffer_shrink[i_t[i]], buffer_shrink[j_t[i]]);
        printf("diva = %e \n", diva_t[i]);
    }
#endif
    free(buffer_shrink);
    printf("End time\n");
    print_time(start_time);
    system("pause");
    return 0;
}

