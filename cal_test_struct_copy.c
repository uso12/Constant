//currently only changed map 
#include <stdio.h>
#include <stdlib.h> // handle system("pause"), prohibit CMD exit after finish
#include <math.h>
#include <time.h>

#define list 4000000000LL // Result list
//-------------------------------------------------------------------------------------------------//
// Target Diva
#define Target_number (double)8.080174247945128e+53 // 8.08017424794512875815e+53 //double t;t=powl(2,46)*powl(3,20)*powl(5,9)*powl(7,6)*powl(11,2)*powl(13,3)*17*19*23*29*31*41*47*59*71;printf("%.15Le\n",t);
// Constants used to approach the target number
#define self 1 // could be generated by ^0
// Physics
#define Speed_of_light 2.99792458e8
#define Proton_length 1.754e-15 // 0.84e-15--0.87e-15/0.833e-15
#define Planck_constant 6.62607015e-34
#define Planck_constant_reduced 1.054571817646156391262428e-34
#define Planck_time 5.39116e-44
#define Planck_mass 2.176434e-8
#define Planck_length 1.616229e-35
#define Proton_mass 1.6726231e-27
#define Gravitational_constant 6.67430e-11
#define Charge 1.602176e-19
#define Vacuum_Permittivity_E0 8.854187817e-12
#define Vacuum_Permittivity_u0 1.25663706212e-6
#define Coulomb_constant_F 8.9875517923e9
#define Conductance_quantum 7.748091729e-5
#define Wien_constant 2.897771955e-3
// Chemistry
#define Boltzmann_constant 1.380649e-23
#define Stefan_Boltzmann_constant 5.670374419e-8
#define gas_constant_R 8.3144598
//#define Faraday_constant_F 9.648533212e4 //=eNA
#define Avogadro_constant 6.02214076e23
// Math
#define Chaos_costant 4.6692016
#ifndef Pi
#define Pi 3.1415926535897932384626433832795
#endif
#define mathematical_constant_e 2.71828182845904523536028747135266249775724709369995
#define golden_ratio 1.6180339887498948482045868343656

//-------------------------------------------------------------------------------------------------//
// Deviation define Used to control the double calculation precision
const double EPS = 1e-15; // double percision
//const double EPS_debug = 4.5e-16; //4e-17 for 7.662571e-011
// #define uper 7.194727e+077
// #define lower 8.904174e+023 //final line of sorted buffer gen
#define uper 9.639690e+111
#define lower 1.193005e+058 // final line of unsorted buffer gen
//-------------------------------------------------------------------------------------------------//
// Control
#define Target_diva_point 1e-13 // 3.42e-14
#define Target_diva_map_max 1e-8//1e-9//1e-10
#define Target_diva_map_min 1e-17//1e-10//1e-17
#define Target_diva_debug 5.427871e-010//3.834622e-011//7.662571e-011//5.412208e-010 //old 9.861436e-010 9.861434e-010
#define All_pass_start 0                // 8250000//分段时开始计算偏移的数组头，legacy parameter
#define All_pass_end i1_t[power_length - 1] / 3
// Choose one of the following
#define all_pass
//#define write_to_file //write original que to txt(no use too big of a file)
//#define debug // final step

// Choose one of the following
// #define my_sort
#define my_qsort

// Choose one of the following
// #define point
#define map
#define map_diva_check 7.346829e-009//7.331057e-010
// #define debug_point// penultimate step

#define print_buffer_before_sort_struct
#define print_buffer_before_shrink_struct
#define print_buffer_after_shrink_struct
// #define print_buffer_before_sort
// #define print_buffer_before_shrink
// #define print_buffer_after_shrink
// #define print_single_point
//--------------------------------------Global Variables----------------------------------------------//
unsigned long long count = 0;      // Remaining data after deletion of duplicate data
unsigned long long count_del = 0;   // Deleted duplicate data
unsigned long long local_count = 0; // Count within the specified deviation
clock_t start_time;                 // Start time
unsigned long long q_left = 0, q_right;
#ifdef all_pass
    int *i_t, *j_t;
    double *s1_t, *s2_t;
    double *diva_t;
#endif
#ifndef multi_thread

typedef struct cal_test_struct
{
    unsigned char i,j,k,l,m,o;
    double data;
} expression;

#define max1 645000000LL//3652745460LL // Original buffer
double *buffer_original, *buffer_original_save; // Original array
double *buffer_shrink, *buffer_shrink_save;     // Array left after deletion
expression *buffer_original_struct, *buffer_original_struct_save = NULL; // struct_diva_list
unsigned long long total_pushed = 0;            // Number of elements before sorting
unsigned long long zero = 0;
#endif
// double stack[] = {
//     Planck_length, Planck_mass, Planck_time, Planck_constant,
//     Speed_of_light, Charge, Avogadro_constant, Gravitational_constant, Boltzmann_constant,
//     Pi, Chaos_costant, mathematical_constant_e, golden_ratio, Vacuum_Permittivity_E0,
//     Proton_length, Proton_mass, Stefan_Boltzmann_constant, gas_constant_R
//     ,Planck_constant_reduced, Vacuum_Permittivity_u0
//     ,Coulomb_constant_F, Conductance_quantum, Wien_constant
// };//the original stack
double stack[] = {
    Planck_length, Planck_mass, Planck_time, Planck_constant,
    Charge, Avogadro_constant, Gravitational_constant, Boltzmann_constant,
    Pi, Chaos_costant, mathematical_constant_e, golden_ratio, Vacuum_Permittivity_E0,
    Proton_length, Proton_mass, Stefan_Boltzmann_constant
    , Planck_constant_reduced, Vacuum_Permittivity_u0
    , Coulomb_constant_F, Conductance_quantum, Wien_constant
}; // After the first round of two similar, delete speed of light and gas constant for practicality
int length_ele;            // Calculate length: printf("%d\n", sizeof(stack) / sizeof(stack[0]));
int length_ele_extended;

//--------------------------------------User Functions--------------------------------------------//
//void quicksort(int left, int right, double *buffer);
double calculate_divation(double result)
{
    return result / Target_number - 1;
}
void quicksortDouble(long int left, long int right, double *buffer)
{
    long int i = left, j = right;
    double mid = buffer[(left + right) / 2];
    double t;
    while (i <= j)
    { //The values ​​of i and j will jump. When the loop ends, i>j
        while (buffer[i] < mid)
            i++;
        while (buffer[j] > mid)
            j--;
        if (i <= j)
        {
            t = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = t;
            i++;
            j--;
        }
    }
    if (i < right)
        quicksortDouble(i, right, buffer);
    if (left < j)
        quicksortDouble(left, j, buffer);
}
void quicksortUChar(int left, int right, unsigned char *buffer)
{
    int i = left, j = right;
    unsigned char mid = buffer[(left + right) / 2];
    unsigned char t;
    while (i <= j)
    { //The values ​​of i and j will jump. When the loop ends, i>j
        while (buffer[i] < mid)
            i++;
        while (buffer[j] > mid)
            j--;
        if (i <= j)
        {
            t = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = t;
            i++;
            j--;
        }
    }
    if (i < right)
        quicksortUChar(i, right, buffer);
    if (left < j)
        quicksortUChar(left, j, buffer);
}
void quicksortLongLong(int left, int right, long long *buffer)
{
    int i = left, j = right;
    long long mid = buffer[(left + right) / 2];
    long long t;
    while (i <= j)
    { //The values ​​of i and j will jump. When the loop ends, i>j
        while (buffer[i] < mid)
            i++;
        while (buffer[j] > mid)
            j--;
        if (i <= j)
        {
            t = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = t;
            i++;
            j--;
        }
    }
    if (i < right)
        quicksortLongLong(i, right, buffer);
    if (left < j)
        quicksortLongLong(left, j, buffer);
}
int qsort_cmp(const void *a, const void *b)
{
    return ((*(double *)a - *(double *)b) > 0 ? 1 : -1); // Ascending order
    // return ((*(double *)a - *(double *)b) < 0 ? 1 : -1); // Descending order
}
int qsort_cmp_struct(const void *a, const void *b)
{
    const expression* x = a;
    const expression* y = b;
    return ((x->data - y->data) > 0 ? 1 : -1); // Ascending order
    // return ((*(double *)a - *(double *)b) < 0 ? 1 : -1); // Descending order
}
void print_time(clock_t func_time)
{
    clock_t end_time;
    end_time = clock();
    printf("%lf\n", (double)(end_time - func_time) / CLOCKS_PER_SEC);
}
//---------------------------------------MAIN---------------------------------------------//
int main(void)
{
    double Exponent_TDD = floor(log10(Target_diva_debug));//Exponent_TDD means number after E; It's alwayas gonna be lower than 0
    
    // if ((fabs(5.412208e-010 - Target_diva_debug)) < 4.5*1/pow(10,abs(Exponent_TDD)+5) && Exponent_TDD < 0)
    // {
    //     printf("successful_1\n");
    //     printf("%lf %e %e\n",Exponent_TDD,4.5*1/pow(10,abs(Exponent_TDD)+5),fabs(5.412208e-010 - Target_diva_debug));
    // }
    // Exponent_TDD = floor(log10(5.412211e010));
    // if (fabs(5.412208e010 - 5.412211e010) < 4.5*(pow(10,abs(Exponent_TDD)-5)) && Exponent_TDD > 0)
    // {
    //     printf("successful_2\n");
    //     printf("%lf %e %e\n",Exponent_TDD,4.5*(pow(10,abs(Exponent_TDD)-5)),(fabs(5.412208e010 - 5.412211e010)));
    // }

    printf("Started\n");
    printf("size of double = %d, size of struct = %d\n", sizeof(double), sizeof(buffer_original_struct[0]));
    start_time = clock();
    length_ele = sizeof(stack) / sizeof(stack[0]);
    length_ele_extended = sizeof(stack) / sizeof(stack[0]) * 7;//4 types of ^
    printf("length_ele = %d length_ele_extended = %d\n", length_ele, length_ele_extended);//符合定义的函数组
//--------------------------------single_thread_gen-----------------------------------------//
    buffer_original = (double *)malloc(max1 * sizeof(double));
    buffer_original_save = buffer_original;
    buffer_original_struct = (expression *)malloc(max1 * sizeof(expression));
    if(NULL == buffer_original_struct)
	{
		perror("malloc error");
		return -1;
	}
    buffer_original_struct_save = buffer_original_struct;
    //buffer_shrink = (double *)malloc(max2 * sizeof(double));
    //buffer_shrink_save = buffer_shrink;
    long long i, j;
    int k, l, m, o;
    double s1, s2, s3, s4, s5, s6;
    double stack_extended[length_ele_extended];

    for (i = 0; i < length_ele; i++)
    {
        stack_extended[i + 0 * length_ele] = stack[i];
        stack_extended[i + 1 * length_ele] = powl(stack[i], 0.5);
        stack_extended[i + 2 * length_ele] = powl(stack[i], 1./3);
        stack_extended[i + 3 * length_ele] = powl(stack[i], 1./4);
        stack_extended[i + 4 * length_ele] = powl(stack[i], 2);
        stack_extended[i + 5 * length_ele] = powl(stack[i], 3);
        stack_extended[i + 6 * length_ele] = powl(stack[i], 4);
    }
//-------------------------------new_single_thread_gen---------------------------------------//
    for (i = 0; i < length_ele_extended; i++) // Generate a group of 6 constant multiply with each other
        for (j = i + 1; j < length_ele_extended; j++)
            if(i % length_ele != j % length_ele)// Prevent the same constant from appearing repeatedly within a single expression
            for (k = j + 1; k < length_ele_extended; k++)
                if(i % length_ele != k % length_ele)
                if(j % length_ele != k % length_ele)
                for (l = k + 1; l < length_ele_extended; l++)
                    if(i % length_ele != l % length_ele)
                    if(j % length_ele != l % length_ele)
                    if(k % length_ele != l % length_ele)
                    for (m = l + 1; m < length_ele_extended; m++)
                        if(i % length_ele != m % length_ele)
                        if(j % length_ele != m % length_ele)
                        if(k % length_ele != m % length_ele)
                        if(l % length_ele != m % length_ele)
                            {
                                *buffer_original = stack_extended[i] * stack_extended[j] * stack_extended[k] * stack_extended[l] * stack_extended[m];
                                buffer_original_struct->i = (unsigned char)i;
                                buffer_original_struct->j = (unsigned char)j;  
                                buffer_original_struct->k = (unsigned char)k;
                                buffer_original_struct->l = (unsigned char)l;
                                buffer_original_struct->m = (unsigned char)m;
                                buffer_original_struct->o = (unsigned char)o;
                                buffer_original_struct->data = *buffer_original;
    #ifdef debug
                                //if ( fabs(*buffer_original-uper)<EPS_debug || fabs(*buffer_original-lower)<EPS_debug)
                                //0.999999 or 1.0000001
                                if ((*buffer_original >= uper * 0.99999 & *buffer_original <= uper * 1.000001) || (*buffer_original >= lower * 0.999999 & *buffer_original <= lower * 1.00001))
                                {
                                    printf("count = %d\n", total_pushed);
                                    printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                                    // printf("stack[i] = %e stack[j] = %e stack[k] = %e stack[l] = %e stack[m] = %e stack[o] = %e\n",stack[i],stack[j],stack[k],stack[l],stack[m],stack[o]);
                                    // printf("s1 == %.1f s2 == %.1f s3 == %.1f s4 == %.1f s5 == %.1f s6 == %.1f\n",  s1, s2, s3, s4, s5, s6);
                                    printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n",
                                        stack_extended[i], stack_extended[j], stack_extended[k], stack_extended[l], stack_extended[m], stack_extended[o]);
                                    printf("*buffer_original == %e", *buffer_original);
                                    printf("\n\n");
                                }
    #endif
                                if (*buffer_original == 0 || *buffer_original < 0 ) // Deal with Constant that goes beyound float calculation percision
                                {
                                    if (zero < 100)
                                    {
                                        // printf("i == %d j == %d k == %d l == %d m == %d o == %d\n", i, j, k, l, m, o);
                                        // printf("A_buffer == %e B_buffer == %e C_buffer == %e D_buffer == %e E_buffer == %e F_buffer == %e\n",
                                        // stack_extended[i],stack_extended[j],stack_extended[k],stack_extended[l],stack_extended[m],stack_extended[o]);
                                        // printf("*buffer_original == %e\n", *buffer_original);
                                    }
                                    zero++;
                                }
                                else
                                {
                                    buffer_original_struct++;
                                    buffer_original++;
                                    total_pushed++;
                                    if (total_pushed % 50000000 == 0)
                                        printf("push = %lld buffer_current = %e\n", total_pushed, *(buffer_original - 1));
                                }
                            }
    printf("count = %ld count_del = %ld i= %lld\n", count, count_del, total_pushed);
#ifdef print_buffer_zero
    // Check overflow totol number
    printf("total pushed before quick sort =%d zero = %d\n", total_pushed, zero);
#endif
    buffer_original = buffer_original_save;
    buffer_original_struct = buffer_original_struct_save;
//--------------------------------------quick sort--------------------------------------------//
#ifdef print_buffer_before_sort_struct
    printf("before sort struct\n");
    for(i=0;i<30;i+=5)
    {
        printf("struct %d %d %d %d %d %d %e ",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                    (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                    (buffer_original_struct+i)->data);
        printf("original buffer = %e\n",*(buffer_original+i));
    }
#endif
#ifdef print_buffer_before_sort
    printf("before sort\n");
    printf("total_pushed = %ld\n", total_pushed);
    printf("original buffer before quicksort tail=%e tail+1 = %e head=%e\n", buffer_original[total_pushed - 1], buffer_original[total_pushed], buffer_original[0]);
    printf("head10\n");
    for (i = 0; i < 10; i++)
        printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
    printf("tail10\n");
    for (i = total_pushed - 10; i < total_pushed; i++)
        printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
#endif

#ifdef my_sort
    printf("Time before my_quicksort\n");
    print_time(start_time);
    buffer_original = (double *)malloc(max1 * sizeof(double));
    buffer_original = buffer_original_save;
    quicksortDouble(0, total_pushed - 1, buffer_original);
    printf("Time after my_quicksort\n");
    print_time(start_time);
#endif
#ifdef my_qsort
    printf("Time before qsort1\n");
    // print_time(start_time);
    // // buffer_original = buffer_original_save;
    // qsort(buffer_original, total_pushed, sizeof(double), qsort_cmp);
    // printf("Time after qsort1\n");
    print_time(start_time);
    qsort(buffer_original_struct, total_pushed, sizeof(buffer_original_struct[0]), qsort_cmp_struct);
    printf("Time after qsort2\n");
    print_time(start_time);
#endif
#ifdef print_buffer_before_shrink_struct
    printf("after quicksort before shirink struct\n");
    for(i=0;i<30;i+=5)
    {
        printf("struct %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                    (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                    (buffer_original_struct+i)->data);
    }
#endif
#ifdef print_buffer_before_shrink
    printf("after quicksort before shirink\n");
    for (i = 0; i < 100; i++)
        printf("count = %ld buffer_original[i] = %e\n", i, buffer_original[i]);
    printf("original buffer after quicksort tail=%e tail+1 = %e head=%e\n", buffer_original[total_pushed - 1], buffer_original[total_pushed], buffer_original[0]);
    printf("total_pushed = %ld\n", total_pushed);
#endif
    //buffer_original = buffer_original_save;
    buffer_original_struct = buffer_original_struct_save;
    q_left = 0;
    count_del = 0;
    count = 0;
    for (q_right = 1; q_right < total_pushed; q_right++) // Deleted duplicate data
    {
        if (q_right % 200000000 == 0)
            printf("count = %lld count_del = %lld i = %lld\n", count, count_del, q_right);
        if ((buffer_original_struct+q_left)->data != (buffer_original_struct+q_right)->data)
        //if (buffer_original[q_left] != buffer_original[q_right])
        {
            q_left++;
            (buffer_original_struct+q_left)->data = (buffer_original_struct+q_right)->data;
            //buffer_original[++q_left] = buffer_original[q_right];
            count++;
        }
        else
        {
            // printf("%e %e\n",buffer_original[i],buffer_original[i+1]); // Determine if the deletion is valid
            count_del++;
        }
    }
    buffer_original_struct = buffer_original_struct_save;
    // buffer_original = buffer_original_save;
    printf("Time after deleting duplicate\n");
    print_time(start_time);
    printf("count = %ld count_del = %ld\n", count, count_del);
#ifdef write_to_file
    FILE *file_c;
    errno_t err_c = fopen_s(&file_c, "constant.txt", "w");
    if (err_c != 0)
    {
        printf("constant.txt open failed\n");
        return -1;
    }
    for (i = 0; i < count; i++)
    {
        fprintf(file_c, "%e ", buffer_original[i]); 
    }
    fclose(file_c); // 关闭文件d
    buffer_original = buffer_original_save;
#endif
#ifdef print_buffer_after_shrink_struct
    printf("print_buffer_after_shrink_struct\n");
    for(i=count - 30;i < count + 10;i+=5)
    {
        printf("struct %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                    (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                    (buffer_original_struct+i)->data);
    }
    i = count-1;
    printf("last count struct %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                    (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                    (buffer_original_struct+i)->data); // 确认count-1是最后的对尾，count中无数据
#endif
#ifdef print_buffer_after_shrink
    for (i = count - 100; i < count + 10; i++)
        printf("count = %ld buffer_shrink[i] = %e\n", i, buffer_original[i]);
    printf("count = %ld buffer_shrink's tail count - 1 = %e\n", count - 1, buffer_original[count - 1]);
    printf("count = %ld buffer_shrink's tail count + 1 = %e\n", count + 1, buffer_original[count + 1]);
    printf("count = %ld buffer_shrink's tail count = %e\n", count, buffer_original[count]); // 确认count-1是最后的对尾，count中无数据
#endif
//-------------------------------------all_pass------------------------------------------//
// Power function grouping and classification
#ifdef all_pass
    double ideal_number;          // The target value in the ideal scenario
    double diva_plus, diva_minus; // Deviations on the right and left after insertion
    double EPS_debug, EPS_map;
    long long compareTemp;
    long long *bothNumDen;
    bothNumDen = (long long *)malloc(4000 * sizeof(long long));
    int count_single_point1[length_ele_extended];
    int count_single_point2[length_ele_extended];
    int count_single_point1_mode[length_ele];
    int count_single_point2_mode[length_ele];
    int count_single_point_sum = 0;//one constant number
    int count_single_point_with_same_constant_sum = 0;
    unsigned char *buffer_mode;//10 for now, 12 for later with 6 for
    buffer_mode = (unsigned char *)malloc(10 * sizeof(unsigned char));
    unsigned char flag_same_number = 0;
    for(i=0;i<10;i++)
        buffer_mode[i] = 0;
    for(i=0;i<length_ele_extended;i++)
        count_single_point1[i] = 0,count_single_point2[i]=0;
    for(i=0;i<length_ele;i++)
        count_single_point1_mode[i] = 0,count_single_point2_mode[i]=0;
    // i_t = (int *)malloc(list * sizeof(int));
    // j_t = (int *)malloc(list * sizeof(int));
    // s1_t = (double *)malloc(list * sizeof(double));
    // s2_t = (double *)malloc(list * sizeof(double));
    diva_t = (double *)malloc(list * sizeof(double));
    j = 0;
    local_count = 0;
    printf("all_pass_started\n");
//-------------------------------------remember to check count + 1------------------------------------------//
    for (i = All_pass_start; i < All_pass_start + count + 1; i++) // i1_t[power_length-1] All_pass_end
    {
        ideal_number = Target_number * (buffer_original_struct+i)->data;
        // ideal_number = Target_number * buffer_original[i];
        if (ideal_number > (buffer_original_struct + count - 1)->data)
        // if (ideal_number > buffer_original[count - 1])
            break; // Exit the loop if the target value is greater than the maximum in the array
        while ((buffer_original_struct+j)->data < ideal_number)
        // while (buffer_original[j] < ideal_number)
        {
            if (j < count)
                j++; // Move j within the count to avoid going out of bounds, j is continuously recorded, not repeated much
        }
        // printf("ideal_number = %e number_in_que-1 = %e number_in_que+1 = %e\n",ideal_number,buffer_shrink[j-1],buffer_shrink[j]);
        // printf("%d\n",j);
        diva_minus = -calculate_divation((buffer_original_struct+j-1)->data / (buffer_original_struct+i)->data); // Left
        diva_plus = calculate_divation((buffer_original_struct+j)->data / (buffer_original_struct+i)->data);       // Right
        // diva_minus = -calculate_divation(buffer_original[j - 1] / buffer_original[i]); // Left
        // diva_plus = calculate_divation(buffer_original[j] / buffer_original[i]);       // Right
#ifdef debug_point
        // double EPS_debug = 4.5e-16;
        // Exponent_TDD = floor(log10(Target_diva_debug));
        if (1) // i % 100 == 0 //if print items became too many
        if(Exponent_TDD < 0)
        {
            EPS_debug = 1*1/pow(10,abs(Exponent_TDD)+6);
            if ((fabs(diva_minus - Target_diva_debug)) < EPS_debug)
            {
                local_count++;
                printf("diva_minus ");
                printf("1 %e 2 %e diva= %e ", buffer_original[j - 1], buffer_original[i], diva_minus);
                printf("%e %e\n",EPS_debug,(fabs(diva_minus - Target_diva_debug)));
            }
            if ((fabs(diva_plus - Target_diva_debug)) < EPS_debug)
            {
                printf("diva_plus ");
                local_count++;
                printf("1 %e 2 %e diva= %e ", buffer_original[j - 1], buffer_original[i], diva_plus);
                printf("%e %e\n",EPS_debug,(fabs(diva_plus - Target_diva_debug)));
            }
        }
        j--;
#endif
#ifdef point
        if (diva_minus < diva_plus && diva_minus < Target_diva_point)
        {
            i_t[local_count] = i;
            j_t[local_count] = j - 1;
            diva_t[local_count] = diva_minus;
            local_count++;
        }
        else if (diva_plus < diva_minus && diva_plus < Target_diva_point)
        {
            i_t[local_count] = i;
            j_t[local_count] = j;
            diva_t[local_count] = diva_plus;
            local_count++;
        }
        j--;
#endif
#ifdef map
        Exponent_TDD = floor(log10(map_diva_check));//Exponent_TDD means number after E; It's alwayas gonna be lower than 0
        EPS_map = 1*1/pow(10,abs(Exponent_TDD)+6);  
        flag_same_number=0;
        //flag_same_number reduce the overall map count
        if (diva_minus < diva_plus && diva_minus < Target_diva_map_max && diva_minus > Target_diva_map_min)
        {
            buffer_mode[0] = (buffer_original_struct+i)->i % length_ele, buffer_mode[1] = (buffer_original_struct+i)->j % length_ele, buffer_mode[2] = (buffer_original_struct+i)->k % length_ele;
            buffer_mode[3] = (buffer_original_struct+i)->l % length_ele, buffer_mode[4] = (buffer_original_struct+i)->m % length_ele;
            buffer_mode[5] = (buffer_original_struct+j-1)->i % length_ele, buffer_mode[6] = (buffer_original_struct+j-1)->j % length_ele, buffer_mode[7] = (buffer_original_struct+j-1)->k % length_ele;
            buffer_mode[8] = (buffer_original_struct+j-1)->l % length_ele, buffer_mode[9] = (buffer_original_struct+j-1)->m % length_ele;
            for(k=0;k<10;k++)
                for(l=k+1;l<10;l++)
                    if(buffer_mode[k] == buffer_mode[l]) flag_same_number=1,k=10;
            if (flag_same_number == 0)
            {
            diva_t[local_count] = diva_minus;
            local_count++;
            if (fabs(diva_minus-map_diva_check) < EPS_map)// check one specific diva
            {
                // original individual data
                // printf("local_count = %d %e %e\n ", local_count,diva_minus,EPS_map);
                // printf("struct i = %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                //     (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                //     (buffer_original_struct+i)->data);
                // printf("struct j-1 = %d %d %d %d %d %d %e \n",(buffer_original_struct+j-1)->i,(buffer_original_struct+j-1)->j,(buffer_original_struct+j-1)->k,
                //     (buffer_original_struct+j-1)->l,(buffer_original_struct+j-1)->m,(buffer_original_struct+j-1)->o,
                //     (buffer_original_struct+j-1)->data);
                // printf("\n");

                //already done the mode step previously
                // buffer_mode[0] = (buffer_original_struct+i)->i % length_ele, buffer_mode[1] = (buffer_original_struct+i)->j % length_ele, buffer_mode[2] = (buffer_original_struct+i)->k % length_ele;
                // buffer_mode[3] = (buffer_original_struct+i)->l % length_ele, buffer_mode[4] = (buffer_original_struct+i)->m % length_ele;
                // buffer_mode[5] = (buffer_original_struct+j-1)->i % length_ele, buffer_mode[6] = (buffer_original_struct+j-1)->j % length_ele, buffer_mode[7] = (buffer_original_struct+j-1)->k % length_ele;
                // buffer_mode[8] = (buffer_original_struct+j-1)->l % length_ele, buffer_mode[9] = (buffer_original_struct+j-1)->m % length_ele;
                // for(k=0;k<10;k++)
                //     for(l=k+1;l<10;l++)
                //         if(buffer_mode[k] == buffer_mode[l])
                        {
                            // {
                            // quicksortUChar(0,9,buffer_mode);
                            //     compareTemp = 0;
                            //     compareTemp += buffer_mode[9]*1                     +buffer_mode[8]*100;
                            //     compareTemp += buffer_mode[7]*10000                 +buffer_mode[6]*1000000;
                            //     compareTemp += buffer_mode[5]*100000000             +buffer_mode[4]*10000000000;
                            //     compareTemp += buffer_mode[3]*1000000000000         +buffer_mode[2]*100000000000000;
                            //     compareTemp += buffer_mode[1]*10000000000000000     +buffer_mode[0]*1000000000000000000;
                            //     bothNumDen[count_single_point_sum] = compareTemp;
                            // } // num dem in the same place
                                {
                                    quicksortUChar(0,4,buffer_mode);
                                    quicksortUChar(5,9,buffer_mode);
                                    compareTemp = 0;
                                    compareTemp += buffer_mode[9]*1                     +buffer_mode[8]*100;
                                    compareTemp += buffer_mode[7]*10000                 +buffer_mode[6]*1000000;
                                    compareTemp += buffer_mode[5]*100000000;
                                    bothNumDen[2*count_single_point_sum] = compareTemp;
                                    if(compareTemp < 0) printf("%lld",compareTemp);
                                    #ifdef print_single_point
                                        printf("j-1 = %lld %lld\n",compareTemp,count_single_point_sum);
                                    #endif
                                    compareTemp = 0;
                                    compareTemp += buffer_mode[4]*1;
                                    compareTemp += buffer_mode[3]*100         +buffer_mode[2]*10000;
                                    compareTemp += buffer_mode[1]*1000000     +buffer_mode[0]*100000000;
                                    bothNumDen[2*count_single_point_sum+1] = compareTemp;
                                    if(compareTemp < 0) printf("%lld",compareTemp);
                                } // seperate
                            #ifdef print_single_point
                            printf("i = %lld %lld\n",compareTemp,count_single_point_sum);
                            // compareTemp = buffer_mode[9]*1+buffer_mode[8]*100;
                            printf("local_count = %d %.8e %.8e\n ", local_count,diva_minus,EPS_map);
                            count_single_point_with_same_constant_sum++,k=10;
                            printf("struct i mod = %d %d %d %d %d %d\n",(buffer_original_struct+i)->i % length_ele,(buffer_original_struct+i)->j % length_ele,(buffer_original_struct+i)->k % length_ele,
                            (buffer_original_struct+i)->l % length_ele,(buffer_original_struct+i)->m % length_ele,(buffer_original_struct+i)->o % length_ele);
                            printf("struct j-1 mod = %d %d %d %d %d\n\n",(buffer_original_struct+j-1)->i % length_ele,(buffer_original_struct+j-1)->j % length_ele,(buffer_original_struct+j-1)->k % length_ele,
                            (buffer_original_struct+j-1)->l % length_ele,(buffer_original_struct+j-1)->m % length_ele,(buffer_original_struct+j-1)->o % length_ele);
                            #endif
                        } 
                //calculate combined data spread
                count_single_point1[(buffer_original_struct+i)->i]++;
                count_single_point1[(buffer_original_struct+i)->j]++;
                count_single_point1[(buffer_original_struct+i)->k]++;
                count_single_point1[(buffer_original_struct+i)->l]++;
                count_single_point1[(buffer_original_struct+i)->m]++;
                count_single_point2[(buffer_original_struct+j-1)->i]++;
                count_single_point2[(buffer_original_struct+j-1)->j]++;
                count_single_point2[(buffer_original_struct+j-1)->k]++;
                count_single_point2[(buffer_original_struct+j-1)->l]++;
                count_single_point2[(buffer_original_struct+j-1)->m]++;
                count_single_point_sum++;
                //printf("1 %e %e \n", diva_minus, diva_plus);
            }
            }
            // if (local_count % 500000 == 0)
            // {
            //     printf("local_count = %d\n ", local_count);
            //     printf("struct i = %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
            //         (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
            //         (buffer_original_struct+i)->data);
            //     printf("struct j-1 = %d %d %d %d %d %d %e \n",(buffer_original_struct+j-1)->i,(buffer_original_struct+j-1)->j,(buffer_original_struct+j-1)->k,
            //         (buffer_original_struct+j-1)->l,(buffer_original_struct+j-1)->m,(buffer_original_struct+j-1)->o,
            //         (buffer_original_struct+j-1)->data);
            //     printf("\n");
            //     //printf("1 %e %e \n", diva_minus, diva_plus);
            // }
        }
        else if (diva_plus < diva_minus && diva_plus < Target_diva_map_max && diva_plus > Target_diva_map_min)
        {
            buffer_mode[0] = (buffer_original_struct+i)->i % length_ele, buffer_mode[1] = (buffer_original_struct+i)->j % length_ele, buffer_mode[2] = (buffer_original_struct+i)->k % length_ele;
            buffer_mode[3] = (buffer_original_struct+i)->l % length_ele, buffer_mode[4] = (buffer_original_struct+i)->m % length_ele;
            buffer_mode[5] = (buffer_original_struct+j)->i % length_ele, buffer_mode[6] = (buffer_original_struct+j)->j % length_ele, buffer_mode[7] = (buffer_original_struct+j)->k % length_ele;
            buffer_mode[8] = (buffer_original_struct+j)->l % length_ele, buffer_mode[9] = (buffer_original_struct+j)->m % length_ele;
            for(k=0;k<10;k++)
                for(l=k+1;l<10;l++)
                    if(buffer_mode[k] == buffer_mode[l]) flag_same_number=1,k=10;
            if (flag_same_number == 0)
            {
            diva_t[local_count] = diva_plus;
            local_count++;
            if(fabs(diva_plus-map_diva_check) < EPS_map)// check one specific diva
            {
                // printf("local_count = %d %e %e\n ", local_count,diva_plus,EPS_map);
                // printf("struct i = %d %d %d %d %d %d %e\n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
                //     (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
                //     (buffer_original_struct+i)->data);
                // printf("struct j = %d %d %d %d %d %d %e \n",(buffer_original_struct+j)->i,(buffer_original_struct+j)->j,(buffer_original_struct+j)->k,
                //     (buffer_original_struct+j)->l,(buffer_original_struct+j)->m,(buffer_original_struct+j)->o,
                //     (buffer_original_struct+j)->data);
                
                //already done the mode step previously
                // buffer_mode[0] = (buffer_original_struct+i)->i % length_ele, buffer_mode[1] = (buffer_original_struct+i)->j % length_ele, buffer_mode[2] = (buffer_original_struct+i)->k % length_ele;
                // buffer_mode[3] = (buffer_original_struct+i)->l % length_ele, buffer_mode[4] = (buffer_original_struct+i)->m % length_ele;
                // buffer_mode[5] = (buffer_original_struct+j)->i % length_ele, buffer_mode[6] = (buffer_original_struct+j)->j % length_ele, buffer_mode[7] = (buffer_original_struct+j)->k % length_ele;
                // buffer_mode[8] = (buffer_original_struct+j)->l % length_ele, buffer_mode[9] = (buffer_original_struct+j)->m % length_ele;
                // for(k=0;k<10;k++)
                //     for(l=k+1;l<10;l++)
                //         if(buffer_mode[k] == buffer_mode[l])
                        {
                            // {
                            // quicksortUChar(0,9,buffer_mode);
                            //     compareTemp = 0;
                            //     compareTemp += buffer_mode[9]*1                     +buffer_mode[8]*100;
                            //     compareTemp += buffer_mode[7]*10000                 +buffer_mode[6]*1000000;
                            //     compareTemp += buffer_mode[5]*100000000             +buffer_mode[4]*10000000000;
                            //     compareTemp += buffer_mode[3]*1000000000000         +buffer_mode[2]*100000000000000;
                            //     compareTemp += buffer_mode[1]*10000000000000000     +buffer_mode[0]*1000000000000000000;
                            //     bothNumDen[count_single_point_sum] = compareTemp;
                            // } // num dem in the same place
                                {
                                    quicksortUChar(0,4,buffer_mode);
                                    quicksortUChar(5,9,buffer_mode);
                                    compareTemp = 0;
                                    compareTemp += buffer_mode[9]*1                     +buffer_mode[8]*100;
                                    compareTemp += buffer_mode[7]*10000                 +buffer_mode[6]*1000000;
                                    compareTemp += buffer_mode[5]*100000000;
                                    bothNumDen[2*count_single_point_sum] = compareTemp;
                                    if(compareTemp < 0) printf("%lld",compareTemp);
                                    #ifdef print_single_point
                                        printf("j = %lld %lld\n",compareTemp,count_single_point_sum);
                                    #endif
                                    compareTemp = 0;
                                    compareTemp += buffer_mode[4]*1;
                                    compareTemp += buffer_mode[3]*100         +buffer_mode[2]*10000;
                                    compareTemp += buffer_mode[1]*1000000     +buffer_mode[0]*100000000;
                                    bothNumDen[2*count_single_point_sum+1] = compareTemp;
                                    if(compareTemp < 0) printf("%lld",compareTemp);
                                } // seperate
                            #ifdef print_single_point
                            printf("i = %lld %lld\n",compareTemp,count_single_point_sum);
                            //printf("k = %d l = %d buffer_mode[k] = %d buffer_mode[l] = %d\n",k,l,buffer_mode[k],buffer_mode[l]);
                            count_single_point_with_same_constant_sum++,k=10;
                            printf("local_count = %d %.8e %.8e\n ", local_count,diva_plus,EPS_map);
                            printf("struct i mod = %d %d %d %d %d %d divide = %d\n",(buffer_original_struct+i)->i % length_ele,(buffer_original_struct+i)->j % length_ele,(buffer_original_struct+i)->k % length_ele,
                            (buffer_original_struct+i)->l % length_ele,(buffer_original_struct+i)->m % length_ele,(buffer_original_struct+i)->o % length_ele,
                            (buffer_original_struct+i)->i / length_ele);
                            printf("struct j mod = %d %d %d %d %d %d\n",(buffer_original_struct+j)->i % length_ele,(buffer_original_struct+j)->j % length_ele,(buffer_original_struct+j)->k % length_ele,
                            (buffer_original_struct+j)->l % length_ele,(buffer_original_struct+j)->m % length_ele,(buffer_original_struct+j)->o % length_ele);
                            for(m =0;m<10;m++)
                            {
                                printf("%d ",buffer_mode[m]);
                            }
                            printf("\n\n");
                            #endif
                        }
                //calculate combined data spread
                count_single_point1[(buffer_original_struct+i)->i]++;
                count_single_point1[(buffer_original_struct+i)->j]++;
                count_single_point1[(buffer_original_struct+i)->k]++;
                count_single_point1[(buffer_original_struct+i)->l]++;
                count_single_point1[(buffer_original_struct+i)->m]++;
                count_single_point2[(buffer_original_struct+j)->i]++;
                count_single_point2[(buffer_original_struct+j)->j]++;
                count_single_point2[(buffer_original_struct+j)->k]++;
                count_single_point2[(buffer_original_struct+j)->l]++;
                count_single_point2[(buffer_original_struct+j)->m]++;
                count_single_point_sum++;
                //printf("2 %e %e \n", diva_minus, diva_plus);
            }
            }
            // if (local_count % 500000 == 0)
            // {
            //     printf("local_count = %d\n ", local_count);
            //     printf("struct i = %d %d %d %d %d %d %e \n",(buffer_original_struct+i)->i,(buffer_original_struct+i)->j,(buffer_original_struct+i)->k,
            //         (buffer_original_struct+i)->l,(buffer_original_struct+i)->m,(buffer_original_struct+i)->o,
            //         (buffer_original_struct+i)->data);
            //     printf("struct j = %d %d %d %d %d %d %e \n",(buffer_original_struct+j)->i,(buffer_original_struct+j)->j,(buffer_original_struct+j)->k,
            //         (buffer_original_struct+j)->l,(buffer_original_struct+j)->m,(buffer_original_struct+j)->o,
            //         (buffer_original_struct+j)->data);
            //     printf("\n");
            //     //printf("2 %e %e \n", diva_minus, diva_plus);
            // }
        }
        j--;
#endif
    }
    printf("For a single point data, all the points are as follow:\n");
    // for(i=0;i<length_ele;i++)
    // {
    //     printf("i = %d serial = %lld\n",i,bothNumDen[i]);
    // } 
    quicksortLongLong(0,count_single_point_sum*2-1,bothNumDen);
    // for(i=0;i<length_ele;i++)
    // {
    //     printf("i = %d serial = %lld\n",i,bothNumDen[i]);
    // } //checking q_sort
    q_left = 0;
    count_del = 0;
    count = 0;
    // for (q_right = 1; q_right < count_single_point_sum-1; q_right++) // Check if there's the same multiply phase(num with dum together)
    for (q_right = 1; q_right < count_single_point_sum*2-1; q_right++)
    {
        if (q_right % 200000000 == 0)
            printf("i = %lld\n", q_right);

        if (bothNumDen[q_left] != bothNumDen[q_right])
        {
            bothNumDen[++q_left] = bothNumDen[q_right];
            count++;
        }
        else
        {
            printf("bothNumDen = %lld %lld q = left%lld right%lld\n",bothNumDen[q_left],bothNumDen[q_right],q_left,q_right); 
            // Determine if thereare duplicate deletion is valid
            count_del++;
        }
    }
    for(i=0;i<length_ele_extended;i++)
    {
        printf("i = %d      number1 = %d     number2 = %d\n",i,count_single_point1[i],count_single_point2[i]);
        count_single_point1_mode[i % length_ele] += count_single_point1[i];
        count_single_point2_mode[i % length_ele] += count_single_point2[i]; 
    }//combined spread
    printf("\n\n");
    for(i=0;i<length_ele;i++)
    {
        printf("i mode = %d      numberi mode = %d     numberj mode = %d\n",i,count_single_point1_mode[i],count_single_point2_mode[i]);
    }//seperate spread
    printf("\ncount = %ld count_del = %ld\n", count, count_del);
    printf("all sum = %d\n",count_single_point_sum);
    printf("sum with same constant = %d\n",count_single_point_with_same_constant_sum);
//---------------------------------print_result-----------------------------------------//
#ifdef debug_point
    printf("debug_point\n");
    printf("local_count = %ld\n", local_count);
#endif
#ifdef point
    printf("point\n");
    for (i = 0; i < local_count; i++) // Print the smallest diva
    {
        printf("count = %d i = %d j = %d ", i, i_t[i], j_t[i]);
        printf("buffer_original[i] = %e buffer_original[j] = %e ", buffer_shrink[i_t[i]], buffer_shrink[j_t[i]]);
        printf("diva = %e \n", diva_t[i]);
    }
#endif
#ifdef map
    printf("map\n");
    // count each diva number
    int *numbers;
    numbers = (int *)malloc(list * sizeof(int));
    free(buffer_original);
    buffer_original = (double *)malloc(list * sizeof(double));
    buffer_shrink = (double *)malloc(list * sizeof(double) / 4);//buffer_shrink save the final diva list
    buffer_original = diva_t;
    quicksortDouble(0, local_count - 1, diva_t);
    count = 0;
    count_del = 0;
    for (i = 0; i < local_count; i++) //Count each diva number
    {
        Exponent_TDD = floor(log10(buffer_original[i]));//Exponent_TDD means number after E; It's alwayas gonna be lower than 0
        EPS_map = 1*1/pow(10,abs(Exponent_TDD)+8);
        // if(i % 100 == 0) printf("count = %ld count_del = %ld i = %ld\n",count,count_del,i);
        if ((buffer_original[i + 1] - buffer_original[i]) > EPS_map) 
        {                                                            
            buffer_shrink[count] = buffer_original[i];
            numbers[count]++; // counter
            count++;
            if (count % 100000 == 0)
                printf("Buffer_related = %e %e %e  delta_related = %e %e\n",buffer_original[i],buffer_original[i+1],(buffer_original[i+1] - buffer_original[i])
                ,Exponent_TDD,EPS_map); //判断清除条件
        }
        else
        {
            // printf("%e %e\n",buffer_original[i],buffer_original[i+1]); //Judge truely different or not
            numbers[count]++;
            count_del++;
        }
    }
    printf("count = %ld count_del = %ld\n", count, count_del);
    // write into a txt
    FILE *file_d, *file_n;
    errno_t err_d = fopen_s(&file_d, "diva.txt", "w");
    errno_t err_n = fopen_s(&file_n, "number.txt", "w");
    if (err_d != 0)
    {
        printf("diva.txt open failed\n");
        return -1;
    }
    if (err_n != 0)
    {
        printf("number.txt open failed\n");
        return -1;
    }
    for (i = 0; i < count; i++)
    {
        // if(i % 100 == 0)printf("diva = %e number = %d\n", buffer_shrink[i],numbers[i]);
        if(numbers[i] > 10)//10//1000//50000
        {
            fprintf(file_d, "%e\n", buffer_shrink[i]); 
            fprintf(file_n, "%d\n", numbers[i]);       
        }
    }
    printf("min_diva i-1= %e number = %d\n", buffer_shrink[i-1], numbers[i-1]);
    // printf("min_diva i= %e number = %d\n", buffer_shrink[i], numbers[i]); //output is zero
    fclose(file_d); // close file d
    fclose(file_n); // close file n
    free(buffer_original);
    free(buffer_shrink);
#endif
#endif
#ifndef all_pass
    free(buffer_original);
    free(buffer_shrink);
#endif
    printf("End time\n");
    print_time(start_time);
    system("pause");
    return 0;
}
